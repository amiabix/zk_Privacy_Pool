# Privacy Pool Verifier Smart Contract

This directory contains the smart contract implementation for on-chain verification of ZisK privacy pool proofs on the Plasma network.

## Overview

The `PrivacyPoolVerifier` contract enables on-chain verification of zero-knowledge proofs generated by the ZisK zkVM privacy pool implementation. It maintains the privacy pool state, tracks nullifiers to prevent double-spending, and verifies Merkle proofs.

## Contract Features

### Core Functionality
- **Proof Verification**: Verifies ZisK zkVM proofs on-chain
- **State Management**: Maintains Merkle root and pool balance
- **Nullifier Tracking**: Prevents double-spending through nullifier set
- **Merkle Proof Verification**: Validates Merkle proofs for input commitments
- **Replay Protection**: Prevents proof replay attacks

### Security Features
- **Access Control**: Owner-only functions for critical operations
- **Reentrancy Protection**: Prevents reentrancy attacks
- **Input Validation**: Comprehensive validation of all inputs
- **State Consistency**: Ensures state transitions are valid

## Contract Structure

### State Variables
```solidity
struct PoolState {
    bytes32 merkleRoot;      // Current Merkle root
    uint256 poolBalance;     // Current pool balance
    uint256 nullifierCount;  // Number of used nullifiers
    bool initialized;        // Initialization status
}

mapping(bytes32 => bool) public nullifiers;        // Nullifier set
mapping(bytes32 => bool) public verifiedProofs;    // Verified proofs
address public ziskVerifier;                       // ZisK verifier address
```

### Key Functions

#### `initializePool(bytes32 _merkleRoot, uint256 _poolBalance)`
- Initializes the privacy pool with initial state
- Owner-only function
- Can only be called once

#### `verifyAndUpdateProof(...)`
- Verifies a ZisK proof and updates pool state
- Validates all proof conditions
- Updates nullifier set and Merkle root
- Emits events for successful verification

#### `setZiskVerifier(address _ziskVerifier)`
- Sets the ZisK verifier contract address
- Owner-only function
- Required before proof verification

## Proof Structure

The contract expects proof data in the following format:

```solidity
struct ProofData {
    uint256[23] publicInputs;  // 23 u32 values from ZisK output
    bytes proof;               // The actual ZK proof
}
```

### Proof Output Indices
- `0`: Overall validation result
- `1`: Merkle proof validity
- `2`: No double-spend check
- `3`: Signature validity
- `4`: Balance validity
- `5-12`: New Merkle root (8 u32 values)
- `13-14`: New pool balance (2 u32 values)
- `15-22`: Transaction hash (8 u32 values)

## Deployment

### Prerequisites
1. Node.js and npm installed
2. Hardhat configured
3. Private key for deployment account
4. RPC URL for Plasma network

### Installation
```bash
npm install
```

### Configuration
1. Copy `.env.example` to `.env`
2. Set your private key and RPC URLs:
```bash
PRIVATE_KEY=your_private_key_here
POLYGONSCAN_API_KEY=your_polygonscan_api_key
PLASMA_RPC_URL=https://rpc.polygon.technology
```

### Compilation
```bash
npm run compile
```

### Testing
```bash
npm test
```

### Deployment

#### Deploy to Plasma Network
```bash
npm run deploy:plasma
```

#### Deploy to Local Network
```bash
npm run node
npm run deploy:local
```

## Usage

### 1. Deploy Contract
```bash
npm run deploy:plasma
```

### 2. Initialize Pool
```javascript
const verifier = await ethers.getContractAt("PrivacyPoolVerifier", contractAddress);
await verifier.initializePool(initialMerkleRoot, initialBalance);
```

### 3. Set ZisK Verifier
```javascript
await verifier.setZiskVerifier(ziskVerifierAddress);
```

### 4. Verify Proof
```javascript
const proofData = {
    publicInputs: [/* 23 u32 values */],
    proof: "0x..." // ZK proof bytes
};

await verifier.verifyAndUpdateProof(
    proofData,
    inputCommitments,
    outputCommitments,
    nullifiers,
    merkleProofs,
    signature,
    publicKey,
    fee
);
```

## Integration with ZisK

### Proof Generation
1. Generate proof using ZisK zkVM
2. Extract public inputs from ZisK output
3. Format proof data according to contract interface
4. Submit to contract for verification

### Example Integration
```javascript
// Generate proof with ZisK
const ziskProof = await generateZiskProof(transactionData);

// Format for contract
const proofData = {
    publicInputs: ziskProof.publicInputs,
    proof: ziskProof.proof
};

// Verify on-chain
await verifier.verifyAndUpdateProof(proofData, ...);
```

## Security Considerations

### Critical Security Notes
⚠️ **WARNING**: The current implementation contains placeholder cryptographic functions that are NOT secure for production use:

1. **Fake ECDSA Verification**: The contract assumes ZisK proofs are valid without proper verification
2. **Placeholder Merkle Proofs**: Merkle proof verification is simplified
3. **No Real ZK Verification**: The `verifyZiskProof` function is a placeholder

### Production Requirements
Before deploying to mainnet:

1. **Implement Real ZisK Verifier**: Replace placeholder with actual ZisK verifier contract
2. **Secure Merkle Proofs**: Implement proper Merkle tree verification
3. **Audit**: Conduct comprehensive security audit
4. **Testing**: Extensive testing with real ZisK proofs

## Gas Optimization

### Current Gas Usage
- Deployment: ~2,000,000 gas
- Proof Verification: ~500,000 gas (estimated)
- State Updates: ~50,000 gas

### Optimization Strategies
1. Use packed structs for storage
2. Batch multiple operations
3. Optimize Merkle proof verification
4. Use assembly for critical functions

## Monitoring and Events

### Key Events
```solidity
event ProofVerified(
    bytes32 indexed proofHash,
    bytes32 indexed transactionHash,
    bytes32 newMerkleRoot,
    uint256 newPoolBalance,
    bool isValid
);

event PoolStateUpdated(
    bytes32 indexed merkleRoot,
    uint256 poolBalance,
    uint256 nullifierCount
);
```

### Monitoring
- Track proof verification success rates
- Monitor gas usage patterns
- Watch for failed verifications
- Track nullifier usage

## Troubleshooting

### Common Issues

#### "Pool not initialized"
- Solution: Call `initializePool()` first

#### "ZisK verifier not set"
- Solution: Call `setZiskVerifier()` with valid address

#### "Proof already verified"
- Solution: Use a different transaction hash

#### "Nullifier already used"
- Solution: Generate new nullifiers

### Debug Commands
```bash
# Check contract state
npx hardhat console --network plasma
> const verifier = await ethers.getContractAt("PrivacyPoolVerifier", "0x...");
> await verifier.getPoolState();

# Verify contract
npx hardhat verify --network plasma 0x... --constructor-args "[]"
```

## License

MIT License - see LICENSE file for details.

## Support

For issues and questions:
1. Check the troubleshooting section
2. Review the test files for examples
3. Open an issue on GitHub
4. Contact the development team
