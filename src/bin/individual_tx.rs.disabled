#![no_main]
ziskos::entrypoint!(main);

use privacy_pool_zkvm::utxo::UTXOTransaction;
use privacy_pool_zkvm::privacy::{CompletePrivacyPoolExample, PrivacyPoolTransaction};
use privacy_pool_zkvm::TransactionResult;
use ziskos::{read_input, set_output};
use std::convert::TryInto;

fn main() {
    // Read single transaction from input
    let input: Vec<u8> = read_input();
    let transaction: PrivacyPoolTransaction = bincode::deserialize(&input)
        .expect("Failed to deserialize transaction");

    // Create a minimal pool state for validation
    let scope = [0u8; 32]; // Default scope for individual transaction validation
    let mut pool = CompletePrivacyPoolExample::new(scope);

    // Compute transaction hash before processing
    let tx_hash = compute_transaction_hash(&transaction);

    // Process the single transaction
    let result = match pool.process_transaction(&transaction) {
        Ok(true) => TransactionResult::Success,
        Ok(false) | Err(_) => TransactionResult::Failure("Transaction validation failed".to_string()),
    };

    // Output only essential validation results
    match result {
        TransactionResult::Success => {
            // Transaction is valid - output success flag
            set_output(0, 1); // Success flag
            set_output(1, 0); // Error code (none)
        }
        TransactionResult::Failure(_) => {
            // Transaction is invalid - output failure flag
            set_output(0, 0); // Failure flag
            set_output(1, 1); // Error code (validation failed)
        }
    }
    
    // Output transaction hash for reference
    for i in 0..8 {
        let chunk = u32::from_le_bytes(tx_hash[i*4..(i+1)*4].try_into().unwrap());
        set_output(2 + i, chunk);
    }
}

fn compute_transaction_hash(tx: &PrivacyPoolTransaction) -> [u8; 32] {
    use sha2::{Digest, Sha256};
    let mut hasher = Sha256::new();

    // Hash transaction type
    hasher.update(&[tx.transaction_type as u8]);

    // Hash value
    hasher.update(&tx.value.to_le_bytes());

    // Hash recipient
    hasher.update(&tx.recipient);

    // Hash commitment
    hasher.update(&tx.commitment);

    // Hash nullifier
    hasher.update(&tx.nullifier);

    hasher.finalize().into()
}
