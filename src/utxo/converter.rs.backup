//! Secure ETH to UTXO Conversion with Blockchain Integration
//! Implements the complete flow from real ETH deposits to cryptographically secure UTXOs

use crate::utxo::indexing::{IndexedUTXO, UTXOId};
use crate::merkle::EnhancedMerkleTree;
use crate::utxo::utxo::UTXO;
use crate::relayer::{BlockchainClient, DepositEvent, BlockchainConfig};
use web3::types::{Address, U256, H256};
use secp256k1::{Secp256k1, SecretKey as Secp256k1SecretKey};
use sha2::{Sha256, Digest};
use hex;
use rand::{Rng, thread_rng};
use anyhow::{Result, anyhow};
use std::collections::{HashMap, HashSet};
use std::sync::{Arc, Mutex};

/// Nullifier for preventing double-spending
/// Each UTXO has a unique nullifier that gets revealed when spent
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Nullifier(pub [u8; 32]);

/// Secure commitment scheme for UTXOs
/// commitment = hash(value || nullifier_hash || owner_pubkey || blinding_factor)
#[derive(Debug, Clone)]
pub struct SecureCommitment {
    pub hash: H256,
    pub value: u64,
    pub nullifier: Nullifier,
    pub blinding_factor: [u8; 32],
    pub owner_pubkey: [u8; 33], // Compressed public key
}

/// Cryptographic utilities for secure UTXO generation
pub struct CryptoUtils;

impl CryptoUtils {
    /// Generate cryptographically secure random bytes
    pub fn generate_secure_random() -> [u8; 32] {
        let mut rng = thread_rng();
        let mut bytes = [0u8; 32];
        rng.fill(&mut bytes);
        bytes
    }
    
    /// Generate a secure nullifier from secret and index
    /// nullifier = hash(private_key || utxo_index || "nullifier_salt")
    pub fn generate_nullifier(private_key: &[u8; 32], utxo_index: u64) -> Nullifier {
        let mut hasher = Sha256::new();
        hasher.update(private_key);
        hasher.update(&utxo_index.to_le_bytes());
        hasher.update(b"privacy_pool_nullifier_v1");
        let mut nullifier = [0u8; 32];
        nullifier.copy_from_slice(&hasher.finalize());
        Nullifier(nullifier)
    }
    
    /// Generate secure commitment
    /// commitment = hash(value || nullifier || owner_pubkey || blinding_factor)
    pub fn generate_commitment(
        value: u64,
        nullifier: &Nullifier,
        owner_pubkey: &[u8; 33],
        blinding_factor: &[u8; 32],
    ) -> H256 {
        let mut hasher = Sha256::new();
        hasher.update(&value.to_le_bytes());
        hasher.update(&nullifier.0);
        hasher.update(owner_pubkey);
        hasher.update(blinding_factor);
        H256::from_slice(&hasher.finalize())
    }
    
    /// Derive public key from private key
    pub fn derive_pubkey(private_key: &[u8; 32]) -> Result<[u8; 33]> {
        let secp = Secp256k1::new();
        let secret_key = Secp256k1SecretKey::from_slice(private_key)
            .map_err(|e| anyhow!("Invalid private key: {}", e))?;
        let public_key = secp256k1::PublicKey::from_secret_key(&secp, &secret_key);
        Ok(public_key.serialize())
    }
}

/// Privacy Pool Contract Interface with Blockchain Integration
pub struct PrivacyPoolContract {
    blockchain_client: BlockchainClient,
}

impl PrivacyPoolContract {
    pub fn new(config: BlockchainConfig) -> Result<Self> {
        let blockchain_client = BlockchainClient::new(config)?;
        Ok(Self { blockchain_client })
    }

    /// Process a real deposit on the blockchain
    pub async fn process_real_deposit(
        &self,
        depositor: Address,
        value_wei: U256,
        commitment: H256,
    ) -> Result<H256> {
        println!("💰 Processing real ETH deposit to blockchain...");
        println!("   Depositor: {:?}", depositor);
        println!("   Value: {} ETH", value_wei.as_u64() as f64 / 1e18);
        println!("   Commitment: {:?}", commitment);
        
        // Send actual ETH to the privacy pool contract
        let tx_hash = self.blockchain_client.deposit_eth(depositor, value_wei).await?;
        
        // Wait for confirmation
        self.blockchain_client.wait_for_transaction(tx_hash).await?;
        
        println!("✅ deposit confirmed on blockchain: {:?}", tx_hash);
        Ok(tx_hash)
    }
    
    /// Fetch real deposit events from the blockchain
    pub async fn fetch_real_deposits(&self, from_block: u64, to_block: u64) -> Result<Vec<DepositEvent>> {
        let blockchain_events = self.blockchain_client.fetch_deposit_events(from_block, to_block).await?;
        
        // Convert blockchain events to data service events
        let mut events = Vec::new();
        for event in blockchain_events {
            events.push(DepositEvent {
                depositor: event.depositor.to_string(),
                commitment: format!("0x{:x}", event.commitment),
                label: event.label.as_u64(),
                value: event.value.as_u64(),
                precommitment_hash: format!("0x{:x}", event.precommitment_hash),
                block_number: event.block_number,
                transaction_hash: format!("0x{:x}", event.transaction_hash),
                log_index: event.log_index as u32,
                merkle_root: "0x0000000000000000000000000000000000000000000000000000000000000000".to_string(),
            });
        }
        
        Ok(events)
    }
    
    /// Get current blockchain state
    pub async fn get_current_block(&self) -> Result<u64> {
        self.blockchain_client.get_current_block_number().await
    }
}

/// Secure ETH to UTXO Converter with Nullifier Tracking
/// Handles the complete conversion from real ETH deposits to cryptographically secure UTXOs
pub struct ETHToUTXOConverter {
    privacy_pool: PrivacyPoolContract,
    merkle_tree: EnhancedMerkleTree,
    utxo_index: HashMap<H256, IndexedUTXO>, // commitment -> UTXO
    nullifier_registry: Arc<Mutex<HashSet<Nullifier>>>, // Track spent nullifiers
    commitment_to_nullifier: HashMap<H256, Nullifier>, // commitment -> nullifier mapping
    total_deposited: u64, // Track total ETH deposited (in wei)
    total_utxo_value: u64, // Track total UTXO value (in wei)
    next_utxo_index: u64,
}

impl ETHToUTXOConverter {
    pub fn new(privacy_pool: PrivacyPoolContract) -> Self {
        Self {
            merkle_tree: EnhancedMerkleTree::new(),
            utxo_index: HashMap::new(),
            nullifier_registry: Arc::new(Mutex::new(HashSet::new())),
            commitment_to_nullifier: HashMap::new(),
            total_deposited: 0,
            total_utxo_value: 0,
            next_utxo_index: 0,
            privacy_pool,
        }
    }
    
    /// Check if a nullifier has been spent (prevents double-spending)
    pub fn is_nullifier_spent(&self, nullifier: &Nullifier) -> bool {
        let registry = self.nullifier_registry.lock().unwrap();
        registry.contains(nullifier)
    }
    
    /// Mark a nullifier as spent (called during UTXO spending)
    pub fn mark_nullifier_spent(&self, nullifier: Nullifier) -> Result<()> {
        let mut registry = self.nullifier_registry.lock().unwrap();
        if registry.contains(&nullifier) {
            return Err(anyhow!("Double-spend attempt detected: nullifier already spent"));
        }
        let nullifier_bytes = nullifier.0;
        registry.insert(nullifier);
        println!("⚠️  Nullifier marked as spent: {:?}", nullifier_bytes);
        Ok(())
    }
    
    /// Verify total accounting (total deposited should equal total UTXO value)
    pub fn verify_accounting(&self) -> Result<()> {
        if self.total_deposited != self.total_utxo_value {
            return Err(anyhow!(
                "Accounting mismatch: deposited {} wei, UTXOs {} wei",
                self.total_deposited,
                self.total_utxo_value
            ));
        }
        println!("✅ Accounting verified: {} wei deposited = {} wei in UTXOs", 
                 self.total_deposited, self.total_utxo_value);
        Ok(())
    }

    /// Process a real ETH deposit from the blockchain
    pub async fn process_real_eth_deposit(
        &mut self,
        deposit_event: &DepositEvent,
        depositor_private_key: &[u8; 32], // For generating nullifiers
    ) -> Result<Vec<IndexedUTXO>> {
        // Validate deposit amount to prevent overflow
        let value = deposit_event.value;
        if value == 0 {
            return Err(anyhow!("Cannot process zero-value deposit"));
        }
        
        // Check for overflow when adding to total deposited
        self.total_deposited = self.total_deposited.checked_add(value)
            .ok_or_else(|| anyhow!("Overflow in total deposited amount"))?;
        
        println!("💰 Processing REAL ETH deposit from blockchain:");
        println!("   Depositor: {:?}", deposit_event.depositor);
        println!("   Value: {} ETH", value as f64 / 1e18);
        println!("   TX Hash: {:?}", deposit_event.transaction_hash);
        println!("   Block: {}", deposit_event.block_number);
        
        // Generate secure UTXOs with proper cryptography
        // Convert string addresses to proper types
        let depositor_addr = Address::from_slice(&hex::decode(&deposit_event.depositor[2..]).unwrap_or_default());
        let tx_hash = H256::from_slice(&hex::decode(&deposit_event.transaction_hash[2..]).unwrap_or_default());
        
        let utxos = self.split_deposit_into_secure_utxos(
            value,
            depositor_addr,
            tx_hash,
            deposit_event.block_number,
            depositor_private_key,
        )?;
        
        // Process each UTXO with strict error handling
        let mut successful_utxos = Vec::new();
        let mut total_utxo_value = 0u64;
        
        for utxo in utxos {
            match self.add_secure_utxo_to_tree(&utxo) {
                Ok(nullifier) => {
                    // Safely add to total value
                    total_utxo_value = total_utxo_value.checked_add(utxo.value)
                        .ok_or_else(|| anyhow!("Overflow in UTXO value calculation"))?;
                    
                    self.utxo_index.insert(utxo.address.into(), utxo.clone());
                    self.commitment_to_nullifier.insert(utxo.address.into(), nullifier);
                    self.next_utxo_index += 1;
                    println!("   ✅ Added secure UTXO: {} ETH", utxo.value as f64 / 1e18);
                    successful_utxos.push(utxo);
                }
                Err(e) => {
                    // Roll back the deposit if any UTXO fails
                    self.total_deposited = self.total_deposited.checked_sub(value)
                        .unwrap_or(0);
                    return Err(anyhow!("Failed to create UTXO: {} - Rolling back deposit", e));
                }
            }
        }
        
        // Update total UTXO value with overflow check
        self.total_utxo_value = self.total_utxo_value.checked_add(total_utxo_value)
            .ok_or_else(|| anyhow!("Overflow in total UTXO value"))?;
        
        // Verify accounting integrity
        self.verify_accounting()?;
        
        println!("✅ Created {} secure UTXOs from {} ETH real deposit", 
                 successful_utxos.len(), value as f64 / 1e18);
        Ok(successful_utxos)
    }

    /// Split a deposit into secure UTXOs with proper cryptography
    fn split_deposit_into_secure_utxos(
        &self,
        total_value: u64,
        _depositor: Address,
        _tx_hash: H256,
        block_number: u64,
        depositor_private_key: &[u8; 32],
    ) -> Result<Vec<IndexedUTXO>> {
        let mut utxos = Vec::new();
        let mut remaining_value = total_value;
        let mut utxo_index = self.next_utxo_index;
        
        // Derive depositor's public key
        let depositor_pubkey = CryptoUtils::derive_pubkey(depositor_private_key)?;
        
        // Use secure randomization for UTXO sizes (no predictable patterns)
        let mut rng = thread_rng();
        
        while remaining_value > 0 {
            // Determine UTXO size with randomization for privacy
            let max_utxo_size = std::cmp::min(remaining_value, 1000000000000000000); // Max 1 ETH
            let min_utxo_size = std::cmp::min(remaining_value, 100000000000000000); // Min 0.1 ETH
            
            let utxo_value = if remaining_value <= min_utxo_size {
                remaining_value // Use all remaining for last UTXO
            } else {
                // Random size between min and max for privacy
                rng.gen_range(min_utxo_size..=max_utxo_size)
            };
            
            if utxo_value == 0 {
                break;
            }
            
            // Generate cryptographically secure components
            let blinding_factor = CryptoUtils::generate_secure_random();
            let nullifier = CryptoUtils::generate_nullifier(depositor_private_key, utxo_index);
            let commitment = CryptoUtils::generate_commitment(
                utxo_value,
                &nullifier,
                &depositor_pubkey,
                &blinding_factor,
            );
            
            // Create secure UTXO
            let utxo = IndexedUTXO {
                id: UTXOId::new(commitment.into(), utxo_index as u32),
                account_id: 1, // Map to actual account in
                address: commitment.into(),
                value: utxo_value,
                height: block_number as u32,
                spent_in_tx: None,
                blinding_factor,
            };
            
            utxos.push(utxo);
            remaining_value = remaining_value.checked_sub(utxo_value)
                .ok_or_else(|| anyhow!("Underflow in UTXO value calculation"))?;
            utxo_index += 1;
        }
        
        Ok(utxos)
    }

    /// Add a secure UTXO to the tree with nullifier tracking
    fn add_secure_utxo_to_tree(&mut self, utxo: &IndexedUTXO) -> Result<Nullifier> {
        // Extract nullifier from the UTXO (would be derived from the commitment in production)
        // For now, we'll generate it deterministically from the UTXO data
        let mut hasher = Sha256::new();
        hasher.update(&utxo.address);
        hasher.update(&utxo.value.to_le_bytes());
        hasher.update(&utxo.blinding_factor);
        let mut nullifier_bytes = [0u8; 32];
        nullifier_bytes.copy_from_slice(&hasher.finalize());
        let nullifier = Nullifier(nullifier_bytes);
        
        // Check if this nullifier is already spent (shouldn't happen for new UTXOs)
        if self.is_nullifier_spent(&nullifier) {
            return Err(anyhow!("Cannot create UTXO: nullifier already spent"));
        }
        
        // Convert IndexedUTXO to UTXO for the MerkleTree
        let utxo_for_tree = UTXO::new(
            utxo.value,
            utxo.blinding_factor,
            [0u8; 32], // owner
            [0u8; 32], // blinding_factor
            nullifier.0, // nullifier_seed
            [0u8; 32], // commitment
            0, // index
        );
        
        self.merkle_tree.insert_commitment(utxo_for_tree.commitment)
            .map_err(|e| anyhow!("Failed to insert UTXO: {:?}", e))?;
        
        Ok(nullifier)
    }

    /// Get accounting information
    pub fn get_accounting_info(&self) -> (u64, u64, usize) {
        (
            self.total_deposited,
            self.total_utxo_value,
            self.nullifier_registry.lock().unwrap().len(),
        )
    }
    
    /// Get nullifier for a commitment (for spending UTXOs)
    pub fn get_nullifier_for_commitment(&self, commitment: &H256) -> Option<&Nullifier> {
        self.commitment_to_nullifier.get(commitment)
    }

    /// Get the current Merkle root
    pub fn get_merkle_root(&self) -> H256 {
        H256::from_slice(&self.merkle_tree.root)
    }

    /// Get UTXO by commitment
    pub fn get_utxo(&self, commitment: H256) -> Option<&IndexedUTXO> {
        self.utxo_index.get(&commitment)
    }

    /// Get all UTXOs
    pub fn get_all_utxos(&self) -> Vec<&IndexedUTXO> {
        self.utxo_index.values().collect()
    }

    /// Get UTXO count
    pub fn get_utxo_count(&self) -> usize {
        self.utxo_index.len()
    }
}

/// Secure ETH Deposit Processor with Blockchain Integration
/// Handles real ETH deposits from the blockchain and converts them to cryptographically secure UTXOs
pub struct ETHDepositProcessor {
    pub converter: ETHToUTXOConverter,
    last_processed_block: u64,
}

impl ETHDepositProcessor {
    pub fn new(config: BlockchainConfig) -> Result<Self> {
        let privacy_pool = PrivacyPoolContract::new(config)?;
        let converter = ETHToUTXOConverter::new(privacy_pool);
        
        Ok(Self { 
            converter, 
            last_processed_block: 0,
        })
    }

    /// Process real deposits from the blockchain
    pub async fn process_real_deposits(
        &mut self,
        depositor_private_key: &[u8; 32], // In this would be managed securely
    ) -> Result<Vec<IndexedUTXO>> {
        // Get current blockchain state
        let current_block = self.converter.privacy_pool.get_current_block().await?;
        
        // Fetch new deposit events since last processed block
        let deposit_events = self.converter.privacy_pool
            .fetch_real_deposits(self.last_processed_block + 1, current_block)
            .await?;
        
        if deposit_events.is_empty() {
            println!("🔍 No new deposits found on blockchain");
            return Ok(Vec::new());
        }
        
        println!("📥 Found {} new deposit events on blockchain", deposit_events.len());
        
        let mut all_utxos = Vec::new();
        
        for deposit_event in &deposit_events {
            println!("💰 Processing real deposit event:");
            println!("   Depositor: {:?}", deposit_event.depositor);
            println!("   Value: {} ETH", deposit_event.value as f64 / 1e18);
            println!("   TX Hash: {:?}", deposit_event.transaction_hash);
            println!("   Block: {}", deposit_event.block_number);
            
            // Process the real deposit with secure cryptography
            let utxos = self.converter.process_real_eth_deposit(
                deposit_event,
                depositor_private_key,
            ).await?;
            
            println!("🎯 Generated {} secure UTXOs from real deposit", utxos.len());
            for (i, utxo) in utxos.iter().enumerate() {
                println!("   UTXO {}: {} ETH (Commitment: {:?})", 
                         i + 1, 
                         utxo.value as f64 / 1e18,
                         utxo.address);
            }
            
            all_utxos.extend(utxos);
        }
        
        // Update last processed block
        self.last_processed_block = current_block;
        
        // Verify accounting across all deposits
        self.converter.verify_accounting()?;
        
        let (total_deposited, total_utxo_value, spent_nullifiers) = self.converter.get_accounting_info();
        println!("📊 Accounting Summary:");
        println!("   Total Deposited: {} ETH", total_deposited as f64 / 1e18);
        println!("   Total UTXO Value: {} ETH", total_utxo_value as f64 / 1e18);
        println!("   Spent Nullifiers: {}", spent_nullifiers);
        
        Ok(all_utxos)
    }
    
    /// Spend a UTXO (mark its nullifier as spent)
    pub fn spend_utxo(&mut self, commitment: &H256) -> Result<()> {
        if let Some(nullifier) = self.converter.get_nullifier_for_commitment(commitment) {
            self.converter.mark_nullifier_spent(nullifier.clone())?;
            println!("💸 UTXO spent: {:?}", commitment);
            Ok(())
        } else {
            Err(anyhow!("Cannot spend UTXO: commitment not found"))
        }
    }

    /// Get current Merkle root
    pub fn get_merkle_root(&self) -> H256 {
        self.converter.get_merkle_root()
    }

    /// Get UTXO count
    pub fn get_utxo_count(&self) -> usize {
        self.converter.get_utxo_count()
    }

    /// Get all UTXOs
    pub fn get_all_utxos(&self) -> Vec<&IndexedUTXO> {
        self.converter.get_all_utxos()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[tokio::test]
    async fn test_secure_eth_to_utxo_conversion() {
        println!("🧪 Testing secure ETH to UTXO conversion...");
        
        // Create blockchain config for testing
        let config = BlockchainConfig::default();
        
        let mut processor = ETHDepositProcessor::new(config)
            .expect("Failed to create processor");
        
        // Generate a test private key
        let depositor_private_key = CryptoUtils::generate_secure_random();
        
        // Test processing real deposits (would be empty in test environment)
        let utxos = processor.process_real_deposits(&depositor_private_key).await
            .expect("Failed to process real deposits");
        
        println!("✅ Secure ETH to UTXO conversion test passed!");
        println!("   Created {} UTXOs", utxos.len());
        println!("   Merkle root: {:?}", processor.get_merkle_root());
        
        // Test accounting
        let (deposited, utxo_value, spent) = processor.converter.get_accounting_info();
        assert_eq!(deposited, utxo_value, "Accounting should be balanced");
        println!("   Deposited: {} wei, UTXO value: {} wei, Spent: {}", deposited, utxo_value, spent);
    }
}